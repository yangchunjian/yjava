# 盲点总结V1

## 盲点记录
- JVM
- HashMap
- 红黑树
- ConcurrentHashMap
- LeetCode算法
- 工作项目
- Dubbo
- B+树和B树的区别
- CMS和G1垃圾收集器区别
- 数据库索引底层的实现
- Redis哨兵和集群
- Elasticsearch原理
- Java线程通信
- SQL优化
- Java不同版本之间的区别
- 开源框架源码（JFinal，JBoot）
- 消息队列
- 多线程
- Docker
- 网络编程
- Web网络安全
- Shell脚本
- Spring相关的框架
- DDD领域模型
- k8s
- 微服务
- 生产者消费者模式
- 设计模式
- 数据库隔离级别
- Spark和Flink
- Java NIO
- Java线程池
- Java堆、栈、方法区等溢出代码
- Java线程池的核数和物理核配置怎么才合理
- 三次握手，四次挥手
- redis、ZooKeeper分布式锁
- JVM内存模型，GC
- ES优化，脑裂
- i++ 和 i=i+1在字节码文件上怎么实现及区别
- csrf攻击和防御
- 数据库主键设计为自增的好处
- 分库分表
- Spring bean的生命周期
- MySQL索引有哪些
- Java线程池的拒绝策略
- Java线程几个状态之间的转换
- Java队列
- MySQL慢查询
- Java信号量Semaphore，栏珊等
- MyBatis
- SpringBoot  
- SpringJPA  
- MySQL慢查询
- 死锁
- 归并排序
- 快速排序
- synchronized原理
- MQ的消息怎么保证不丢失
- 一个URL到Controller的整个过程是怎么样的
- HTTP与HTTPS的区别
- TCP拥塞控制
- 常用端口号
- ES优化方法
- Http响应码为0
- 线程池核心线程数和最大线程数配置关系
- Kafka的rebalance
- Kafka的重复消费
- 序列化方式，Protobuf实现原理
- Redis分布式锁、ZooKeeper分布式锁
- CMS收集器、G1收集器
- CopyOnWriteArrayList
- ThreadLocal
- AtomicLong
- HashTable
- ConcurrentHashMap
- LinkedHashMap
- TreeMap
- HDFS
- Hadoop
- 脚本语言和编译语言区别
- Redis读写超时了怎么处理，Redis集群的高可用怎么保证
- MySQL连接池打满怎么处理
- MySQL和Redis数据不一致问题怎么解决
- Java线程模型
- Java线程死锁
- Java堆排序
- Java线程占多大的内存
- 为什么快速排序要比堆排序性能好
- Spring的生命周期
- G1和CMS的区别
- Java线程池死锁
- Java内存泄露、溢出
- Java悲观锁和乐观锁
- Java中stream和parallelstream区别
- MySQL事务原子性怎么保证
- MySQL主键生成方式有哪些
- JVM原理
- git rebase和merge区别
- Redis 分布式锁避免死锁
- Idea编码快捷键
- hadoop fs 命令使用
- SpringBoot有什么特性
- MySQL如何解决幻读？
- Netty
- RPC实现
- AQS
- netty4和netty5区别
- Elasticsearch与关系数据库的相关术语的对应关系
- 进程间通信的方式
- Linux难点命令
- redis为什么快
- redis地理空间Geospatial
- Linux命令面试题
- 操作系统常见面试题总结
- 各种服务常用端口号
- Java基础知识
- idea远程调试
- 垃圾收集器G1的回收过程
- Spring循环依赖问题怎么解决
- MySQL MVCC乐观版本并发控制解决了什么问题
- Zookeeper面试题
- JVM 
- 多线程 
- MySQL
- Elasticsearch 
- Redis
- Spring 
- SpringBoot
- SpringCloud
- Java
- ZooKeeper
- Linux
- Kafka
- Spark
- Flink
- Netty
- MyBatis
- Hadoop
- Web
- 微服务
- Dubbo
- 一致性hash算法
- zab协议
- zk和Eureka区别





