# 架构总结

## 设计思想
* 整体局部的思想
* 名词的思想
* 性能的思想
* 解决方案的思想
* 应对对策的思想
* 软硬件的思想
* 业务的思想
* 技术选型的思想
* 整体技术栈(生态)的思想
* 容器的思想
* 上下文的思想
* 非侵入的思想
* 声明式的思想
* 调研的思想
* 拿来主义的思想
* 沉淀架构图的思想
* 思维脑图的思想
* 推送或是拉取的思想
* 异常处理、超时重试的思想
* 流程图思想、时序图的思想
* 文档规范、权限规范的思想
* 流程图、甘特图、时序图、UML图的思想
* 产品经理的思想
* 结构化的思想
* 权限的思想
* 名词、动词的思想
* 前端、后端的思想
* 静态、动态的思想
* 选型的思想
* 类比的思想
* 规模化的思想
* 盈利的思想
* 价值的思想
* 竞品的思想
* 扩展性的思想
* 高可用的思想
* 强曝光的思想
* 过滤器的思想
* 拦截器的思想
* 切面的思想
* 织入的思想
* 插拔式的思想
* 垂直切分、水平切分的思想
* 池化的思想
* 分库分表的思想
* 大文件切割的思想
* 重置的思想
* 回调的思想
* 多字段的思想
* 清晰的思想
* 合理设计的思想
* 解耦的思想
* 第一性原理的思想
* 响应式的思想
* 事件驱动的思想
* 领域驱动的思想
* 上下文的思想
* 结构、规模的思想
* 融会贯通的思想
* 无招胜有招的思想
* 一通百通的思想
* 领域设计的思想
* 战略设计的思想
* 战术设计的思想
* 界限上下文的思想
* 值对象的思想
* 组合的思想
* 聚合的思想
* 问题空间的思想
* 解空间的思想
* 项目管理思想用于系统设计的思想
* 树结构的思想
* 组合模式的思想
* 框架和服务的思想
* 调用关系的思想
* 拆分的思想
* 循序渐进的思想
* 实践出真知的思想
* 拨乱反正的思想
* 人多力量大的思想
* 站在巨人肩膀的思想
* 样例的思想
* 复制的思想
* 拿来主义的思想
* 请教的思想
* 力排众议的思想
* 粮草先行的思想
* 试错的思想
* 并发的思想
* 重在思考的思想
* 从0到1的思想
* 从1到100的思想
* 优化的思想
* 迭代的思想
* 报表的思想
* 哪部分通过库表存储关系的思想
* 哪部分通过程序存储关系的思想
* smart的思想
* 设计思路的思想
* 都可依赖的思想
* 合理依赖的思想
* 对象参数的思想
* 子类区别的思想
* 业务名词的思想
* 业务架构的思想
* 技术架构的思想
* 应用架构的思想
* 视角的思想
* 内容的思想
* 企业架构的思想
* 目录的思想
* 矩阵的思想
* 图形的思想
* 设计模式的使用
* 技术选型的考量
* 配置中心的思想
* 解耦拆分的思想

## 重构思想
* 背景：Go工程重构为Java工程
* 思想：
  * 确定工程边界（组内，组外）
  * 确定工程上下游（产品人，测试人，技术人）
  * 确定对外提供哪些接口（RPC接口？Dubbo？Apollo配置中心？）
  * 确定对外分页方式（分页组件？平滑迁移？哪块做兼容（客户端，后端）？）
  * 确定对外API命名规则（apiV2？）
  * 确定接口文档记录位置（readme文件？wiki？）
  * 确定通用工具（发短信，发邮件，发push，站内信？）
  * 确定技术框架选型（SpringBoot？SpringMVC？JFinal？）
  * 确定工程Module（分几层？每层的作用？）
  * 确定内部职责及交互（多人参与重构，每人职责？）
  * 确定开发、测试、线上的开发分支，及部署环境
  * 确定推送到仓库时，SNAPSHOT、RELEASE版本的差异
  * 确定配置文件，及加载顺序
  * 确定变量是下划线还是驼峰，统一规则
  * 确定是新建表，还是在原有表上增删改字段
  * 确定表的职责，哪些流程操作这个表
  * 确定测试环境、沙箱环境、生产环境域名
  * 确定联调时间、测试时间、上线时间
  * 确定依赖方接口有哪些，及操作哪些库表
  * 确定适配器等
  * 确定某个字段存了哪些类型值
  * **特别重要：优先找之前Go工程的技术人员对接自己的职责**
* 结果：完成重构

## 规范思想
* MD文档规范
* 工程结构规范
* 代码编写规范
* 代码命名规范
* 代码通用规范


## 框架思想
- **首先一定明确技术是为业务服务的，技术只是工具**
- 从内心深处问自己：自己是否确实喜欢编码？还是只是当做糊口的工具？
- 每个框架都有其规则，一般按规则使用，定义规则是本事
- 创造和创新还是有很大区别的，创造是从无到有的过程，创新是从有到精的过程
- 以业务背景为根本，合理实现
- 架构看的更远，更多要了解业务，拆分模块，分层，对应到责任人
- 架构要对各种图各种溜，各种表格各种溜，各种数据各种溜，技术实现靠后了
- 架构也是基于业务的，所有的技术都是为业务服务的
- 流程图、E-R图很重要，也是实现代码的基础
- 设计模式、时序图等，都是技术手段，背后都是解决实际生活问题
- 不需要纠结什么技术好不好，只是在当时当刻哪个技术更合适
- 任何纠结技术本身都是愚蠢行为，抬头看看别家或竞品是怎么设计的
- 类名方法名叫什么不重要，类名方法名做什么的，怎么实现的特别重要
- 别有思维定式，解决问题是根本，其它没那么重要
- 根据业务场景，抽象出对象名词，及确定名词与名词之间的依赖关系
- 从性能思考问题（响应时间、缓存的使用、存储数据的DB用哪个等等）
- 针对具体问题，提出解决方案
- 针对未来会遇到的问题，提出应对对策
- 软件和硬件齐头并进解决业务问题
- 确定技术选型、确定选型版本
- 思考本源问题，思考最简思路
- 追求简单、清晰的架构
- 不要被别人的程序写法框住，知道对方的设计思路更重要
- 最终的底层都是对基础数据类型的操作
- 

## 需求思想

- 先出大纲
- 系统边界
- 时间预估
- 时间校准
- 圈定人员
- 圈定交互
- 代码生成
- 代码实现
- 前端介入
- 前端预估
- 测试介入
- 测试预估

## 开发思想

**一、工程规范**

**1.工程名**

kfs-templateproject，templateproject选用有意义的与业务相关的单词，不要使用英文简称，英文简称容易造成混淆

**2.工程结构（仅针对服务）**

    kfs-templateproject-api
    kfs- templateproject-service                     
**3.模块说明**

`kfs-templateproject-api：rpc对外输出的jar包，给外部系统引用，所以该工程的依赖越简单越好，一般包含：**DTO，**Constant，**Enum，**Api；`

- 不要在该模块中依赖过多的jar包
- 该工程不要依赖日志实现包，如log4j、common-logging、logback
- 禁止在该模块的classpath下定义logback.xml、log4j.properties等可以被加载的文件
- 该工程仅定义一些接口，不要依赖spring等jar包
- kfs-templateproject-service：service层，业务逻辑都写在这里。建议针对接口编写测试用例

以下领域模型使用场景：
    
    DTO：api
    BO：？
    VO：？
    SO：？
Dubbo接口入参和出参格式：入参个数>=4个封装成对象**Param，返回对象**DTO，接口抛业务异常

**4.版本控制**

**4.1 release版本命名：{num1}.{num2}.{num3} 例如: 1.2.0**

- 每次必更，正式版本只能deploy一次，如果已经有人deploy过，再次deploy会失败，请升级版本号。
- 版本号规则：建议默认0，如果版本升级较频繁，为避免版本号交叉冲突，建议使用jira单号、时分秒HH:mm:ss或者一些有意义的字符。

**4.2 snapshot版本命名：{num1}.{num2}.{num3}-SNAPSHOT，例如: 1.2.0-SNAPSHOT**

快照版本支持无限次覆盖上传，前提是版本号必须以-SNAPSHOT结尾。

**5.打包规范**

- 非master分支必须是SNAPSHOT版本
- 只能master分支打RELEASE包
- 日常需求开发，从master分支拉feature分支：feature+业务+日期eg：feature-logFormat-20190714，紧急、小任务拉hotfix

**6.pom依赖**

每个工程仅依赖和自己相关的jar，不要依赖了jar包又不使用

**7.tag文件**

tag文件尽量做到统一，将当前分支打进tag中，便于后面发版同学知道打包使用的分支

**二、代码规范**

- 1.《阿里巴巴Java开发手册终极版v1.3.0》，见附件
- 2.《公司规范》，xxx
- 3.《组内Java开发规范》，即本规范

实际规范以以上三个规范互补，但优先级：3>2>1，即与1或2重叠的地方，以3为准

**编码规范：**

- 严格代码长度，一个方法最好不超过80行，保证可以在一屏上全部显示，一个类最好不超过1000行。
- 数据模型和业务模型最好分开定义，不建议一个数据模型对象全工程使用。
- 对于长整型变量必须使用L严禁使用l，eg：1l造成代码可读性较差。
- 对于重写方法上必须有@Override标注。
- 判断字符串相等建议使用StringUtils.equals。
- 判断字符串为空、非空建议使用StringUtils.isBlank、StringUtils.isNotBlank等。
- 判断Collection是否为空、非空建议使用CollectionUtils.isEmpty、CollectionUtils.isNotEmpty。
- 对于金额的计算必须使用BigDecimal、舍入模式建议选择银行家算法、除法运算必须指定精度。
- 对于金额最好按照最小辅币处理，即人民币按照分处理，100元=10000分。
- 对于金额是否相等的处理，不允许建单使用BigDecimal.equals进行判断。
- 不允许在finally语句中return返回值，否则会将try-catch程序块中的异常吃掉。
- 对于switch语句中的每个case语句，必须要有结束机制，可以使用break或者return，否则可能导致潜在的bug。
- 捕获的异常，不允许不做任何处理就截断，至少要纪录日志，或者包装后重新抛出。
- 对于文件、流IO操作，必须要关闭。
- 对于线程、线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。common-utils
- 对于web不允许处理出现测试后门。

**日志规范**

- 精简打印日志，可读性强，方便排查定位、联调，监控和分析系统运行是否正常。
- 不允许打印大量意义不大的日志，包括联调、临时性的日志，导致大量log影响性能、log文件大、淹没其他有用信息。
- 严禁打印敏感信息，包括用户、系统敏感信息、必须保密的信息，符合安全审计原则。包括身份证、姓名、密码、卡号、签名、私钥、内部系统密码、保密数据等。
- 生产代码禁止以system及printStackTrace的方式输出日志信息，必须用Logger替代。
- 对于异常堆栈的输出，必须log.xxx（”msg”, e）的形式输出，禁止log.xxx（”msg”+e）的错误形式。
- 循环体内尽可能禁止打印Info级别的日志，如果数据量过大会造成日志文件过大。
- Info级别以上的日志，必须携带具有业务含义的数据，严禁输出无业务含义的数据。

**注释规范**

- 类注释：要求简单介绍下该类的主要功能，其他按注释模板生成。
- 类成员变量注释：要求使用文档注释，不建议使用逻辑注释；能够明确指明该成员变量含义，对于有约束的情况需要使用@link指明约束。
- 方法注释：方法注释能够准确反映方法的功能，调用者能够通过注释准确使用该方法；如果是面向接口的，方法的注释要求写在接口上；对于提供给外部系统的API接口注释要求尽可能详细；对于参数的注释要明确含义，以及约束条件；对于返回值也需要明确在什么场景下返回什么值。
- 代码中注释：对于复杂的业务逻辑，需要增加必要的注释，并集中注释列出可能出现的逻辑判断；

**代码提交**

- 提交代码前需要首先更新代码，再提交。
- 提交代码及配置文件时，如果发生冲突，先看历史说明，再找相关人员确认，坚决不允许强制覆盖。
- 每次提交代码之前，必须进行diff检查。
- 提交代码前必须格式化自己新增的代码，老代码暂时就不要动了。
- 及时删除从未用到的或被注释的方法、变量、类、配置文件、动态配置属性等，避免造成过多垃圾，影响代码可读性，可维护性。

**三、数据库规范**

- 《阿里巴巴Java开发手册终极版v1.3.0》，见附件
- 《信息部DB开发规范》: xxx
- 《组内DB开发规范》，即本规范
- 实际规范以2为主，1、3为辅，相冲突时，以2为准

**表设计规范**

- 所有的表字段及表设计，都必须有注释，建表sql最好放在相应工程里。
- 所有的DDL、DML上线前必须由相应工程负责人review。
- 是否需要进行分库分表，在详细设计阶段根据业务量级进行组内设计评审。
- 建表默认字段创建人，更新人，创建时间，更新时间。

**四、上线流程规范**

- 对于P0级或比较重要的项目，上线前一定要请产品、业务方代表到测试环境进行验收，否则不予上线、验收不通过也不予上线。
- 项目较大或者依赖较多的，发布时间持续比较长。可以提前和对应负责人沟通，提早开始部署。

**五、其他建议**

- dubbo依赖和引用的接口建议使用xml方式配置，直观好看，能够非常清晰的知道依赖了哪些外部服务，提供了哪些外部服务。注解方式不直观
- mybatis建议也是采用xml的方式。
- mapper层接口建议一个表一个文件，如果存在连表的情况以主表为主
- idea建议安装代码检查相关插件，便于提示不规范的代码

**六、附件**

```pdf
https://www.yjava.cn/book/阿里巴巴Java开发手册(详尽版).pdf
```

## 库表思想

**数据库使用禁令**

- 禁止直接连接本系统以外的数据库（跨库直连）
  - A 系统不允许使用 B 系统数据库账号跨系统连接读写 B 数据库。
  - 如有数据交换需求必须走接口、离线数仓等其他传输方式。
  
**命名规范**

- 库名、表名、字段名、索引名必须使用小写字母，并采用下划线分割。
- 库名、表名、字段名支持最多 64 个字符但禁止超过 32 个字符。
- 库名、表名、字段名必须见名知意。命名与业务、产品线相关联。
- 库名、表名、字段名禁止使用 MySQL 保留字
    - 如：add/analyze/check/char/to/and/as/before/between/column...)

- 数据库初始化会删除 test 库 ，库名、表名、字段名禁止使用 test 开头。
- 创建一 rubbish 库，存放无效表、垃圾表，线上系统无异常，确认无误后，定期清理。
- 创建一 archive 库，存放本地归档，确认无使用计划后，定期转移到归档备份服务器中。
- 临时库、表名必须以 tmp 为前缀，并以日期为后缀。例如 tmp_table_20140401。
- 不建议使用存储过程、触发器、视图、UDF、EVENT等。
- 账号命名规则：
    - 本业务访问账号：业务名_wn/业务名_rn；
    - 跨业务访问账号：访问组_要访问业务名_w/访问组_要访问业务名_r
  
**库表字段设计规范**

**库设计规范**

- 默认使用 InnoDB 存储引擎。
- 库、表、字段、client 字符集默认可使用 UTF8MB4（支持emoji 等表情符号存储），新项目不再使用 UTF8。
- 单库不要超过 500 个表、单表字段数不要超过 50  个。
- 禁止在数据库中存储图片、文件等大数据。
- 禁止测试环境直连生产环境调试，如有数据测试需求，请走特别申请流程。
- 依据数据冷热，分级存储，历史归档

**表设计规范**

- 前端禁止使用分区表。
- 表、字段添加 comment（除主键）。
- 字符类型居多的表建议控制在 3000W 以内，整型居多的表建议控制在 5000W 以内。
- 将关键字段、使用率频繁的字段拆分到单独表中，将大字段、访问频率低的字段拆分到单独表中存储，冷热分离。
- 推荐使用 HASH、RANGE 进行散表，表名后缀使用数字，数字必须从0开始。
- 散表或归档分表名称需符合 YYYY[MM][DD][HH] 格式，例如 table_201401、table_20140422

**字段设计规范**

表字段少而精，尽量选择最小数据类型，表结构设计时适当冗余，不在数据库上做大量的 CPU 运算

- 建表默认 5 字段，主键、创建时间、创建者、修改时间、修改者。id、create_time、create_user、update_time、update_user。
- 建议使用 UNSIGNED 存储非负数值。
- 建议使用 INT UNSIGNED 存储 IPV4。
- 用 DECIMAL 代替 FLOAT 和  DOUBLE存储精确浮点数，例如支付相关数据。
- 建议整型字段直接使用 INT，INT 类型固定占4字节存储， 默认是 11，最大有效显示宽度是 255，例如 INT(4 )仅代表字符宽度为 4 位，不代表存储长度。
- 区分使用 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 数据类型和取值范围(TINYINT>SMALLINT>MEDIUMINT>INT>BIGINT>DECIMAL---存储空间逐渐变大，而性能却逐渐变差)。
- 禁止字段使用 enum 数据类型。
- 禁止使用 TEXT、BLOB 类型，如须使用，建议和主键一起进行拆表处理，可考虑 VARCHAR 替换。
- 使用 VARBINARY 类型默认区分大小写，没有字符集概念，可存储大小写敏感的变长字符串或二进制内容。
- 使用尽可能小的 VARCHAR 字段。VARCHAR(N) 中的N表示字符数而非字节数。比如VARCHAR(255)，可以最大可存储 255 个汉字，需要根据实际的宽度来选择 N。
- 区分使用 DATETIME 和 TIMESTAMP。存储年使用 YEAR 类型。存储日期使用 DATE 类型。 存储时间(精确到秒)建议使用 TIMESTAMP 类型。
- 所有字段均定义为 NOT NULL。尽量避免使用 NULL，要是必须用 NULL，那也可考虑使用 0、特殊值或空串来进行代替。

**索引设计规范**

- 单张表中索引数量不超过 5 个，单个索引中的字段数不超过 5 个。
- 非唯一索引按照 idx_字段名称[_字段名称] 进行命名。
- 唯一索引按照 uk_字段名称[_字段名称] 进行命名。
- 联合索引建议包含所有字段名，过长的字段名可以缩写形式。
- 表必须有主键，推荐使用 UNSIGNED 自增列作为主键并且该主键为非业务字段。
- 唯一键由 3 个以下字段组成，并且字段都是整形时，可使用唯一键作为主键。其他情况下，建议使用自增列或全局生成器作主键。
- 禁止冗余、重复索引。
- 禁止索引 NULL 列。
- 禁止使用外键，避免产生死锁，通过程序来保证约束。
- 避免数据类型转换，联表查询时，JOIN 列的数据类型必须相同，并且要建立索引。
- 选择区分度大的列建立索引。字段的顺序对组合索引有至关重要的作用，组合索引中，区分度大的字段要放在最前面。
- 不在区分度低的上建立索引，例如 性别。
- 对较长的字符串字段、BLOB、TEXT 使用前缀索引，前缀索引长度不超过 8 个字符。（使用前缀索引，不仅节省存储空间，提高索引缓存命中率，还可减少 disk 的 IO 操作。）
- 不对过长的 VARCHAR 字段建立索引。建议优先考虑添加 CRC32 或 MD5 伪列，并对伪列建立索引，减少索引长度，提高效率。
- 合理创建联合索引，(a，b，c) 相当于 (a) 、(a，b) 、(a，b，c)。
- 合理使用覆盖索引减少 IO，避免排序。
- 添加优化的索引之后，再删除多余的索引。
- 单个索引尽可能覆盖更多的 SQL，更新频率比较高的表要控制索引的数量。
- 大批量变更数据，索引维护成本很高，因此大批量数据更新要拆分出小粒度。

**SQL 设计规范**

- 使用 prepared statement，可以提升性能并避免 SQL 注入。
- 用 IN 代替 OR。SQL语句中 IN 包含的值不应过多，应少于 500 个。
- 禁止隐式类型转换。数值类型禁止加引号；字符串类型必须加引号。
- 避免使用 JOIN 和子查询，禁止使用 3 表以上的 JOIN，必要时推荐用  JOIN代替子查询。
- 避免在 MySQL 中索引列进行数学运算和函数运算。
- 减少与数据库交互次数，尽量采用批量提交 SQL 语句（INSERT INTO table （column1、column2、column3） VALUES(),(),()），不宜过多。
- 拆分复杂 SQL 为多个小 SQL，避免大事务。
- 获取大量数据时，建议分批次获取数据，每次获取数据少于 500 条，结果集应小于 1M。
- 用 UNION ALL 替换 UNION。
- 禁止在前端业务中使用 count(*)，可放在 memcache、redis、某一从库或增加统计表来维护。
- 多表关联时禁止使用 select * 语句，只取需要列。
- SQL 中避免出现 rand()、sysdate()、current_user() 等不确定结果的函数。
- INSERT INTO 语句必须显示指明字段名称。
- 禁止使用 INSERT INTO B SELECT *  FROM  A。
- 禁止单条 SQL 语句同时更新多个表。
- 建议使用合理的分页方式以提高分页效率。
- 禁止在生产环境从库进行查询分析统计操作，必要时请申请专用统计服务器，前后台分离。
- 程序应有捕获 SQL 异常的处理机制，必要时通过 rollback 显式回滚。
- 程序不要修改数据库中事务隔离机制，控制锁的行为。
- 避免全表扫描，重要 SQL 必须被索引：update、delete 的 where 条件列、order by、group by、distinct 字段、多表 join 字段。
- 如果只是分组，用 group by a order by null 替换 group by a 去除排序。
- 禁止使用 % 前导查询，例如：like "%abc"，无法利用到索引。
- 禁止使用负向查询，例如 not in、!=、not like、<>。
- 禁止在 where 子句中对字段进行 null 值判断，字段通过增加默认值处理。
- 使用 EXPLAIN 判断 SQL 语句是否合理使用索引，尽量避免 extra 列出现：Using File Sort、Using Temporary。
- 禁止 DML 语句中出现 @num 变量替代字段名称。
- UPDATE 或 DELETE 语句加上 WHERE 条件索引列更新（如果使用非索引列更新会导致锁全表，造成Lock wait timeout exceeded; try restarting transaction），禁用 LIMIT 语句。
- 拼接 SQL 语句时，注意 where 条件，防止 SQL 注入时表记录被清空（如：delete from where a/a=a/1=1/a=0 or 1=1/exist 返回布尔值为恒真）。
- DML：SQL 语句中不允许有 drop、truncate、delelet all data 等语句。
- DDL：添加字段语句禁止使用 after，特别是对于 mycat 或 gaea 的分布式代理的数据库，如果加上after，会造成数据错误。例如：alter table t add column a after b; 

**如何申请数据库**

- 访问 XXX
- 点击『工单分类』->『资源申请』->『DB 资源申请』，填写工单内容即可


**新建表参考**

**-- 新建表参考：**
    
    create table  tb_cart_goods_special (
      id int unsigned not null  auto_increment,
- com,hk,tw,sg',
     region_name varchar(20) not null default '' comment '区域名称',
     primary key (id)
    ）engine=innodb  auto_increment=1 default charset=utf8 comment='购物车下面单个商品的推荐调整’;
**如何变更数据库**

- 访问 XXX
- 点击『工单分类』->『变更』->『DB 数据变更』，填写工单内容即可


**添加字段参考：**

    alter table tb_cart_goods_special add goods_id int unsigned not null default  '0'  comment  '商品编号’;
**添加索引参考：**

    alter table tb_cart_goods_special add index idx_area(area),add unique index uk_goods_id(goods_id);

注意：
- 任何 ddl/dml 操作语句都不要加数据库名称，由DBA切换到对应的数据库来执行。
- 新建表自增 auto_increment 从 1 开始。
- 工单提交的 SQL，不要加上特殊字符，如 `


## 可用思想

保证系统高可用，可以从哪方面思考？

- 熔断方面
- 兜底方面
- 解耦方面
- 隔离方面
- 异步方面
- 备份方面
- 多活方面
- 主从方面
- 数据库方面
- 中间件方面
- 无状态方面
- 横向扩展方面
- 垂直扩展方面
- 负载均衡方面
- 冷备方面
- 超时控制方面
- 限流方面
- 重试方面
- 补偿方面
- 冗余方面
- 幂等方面
- 治理方面
- 回滚方面
- 监控方面
- 链路方面
